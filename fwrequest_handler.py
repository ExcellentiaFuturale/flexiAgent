#! /usr/bin/python

################################################################################
# flexiWAN SD-WAN software - flexiEdge, flexiManage.
# For more information go to https://flexiwan.com
#
# Copyright (C) 2019  flexiWAN Ltd.
#
# This program is free software: you can redistribute it and/or modify it under
# the terms of the GNU Affero General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option) any
# later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
# or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <https://www.gnu.org/licenses/>.
################################################################################

import fwglobals
import fwutils
import traceback
import json
import re

class FwRequestHandler:
    """This is Request Handler class representation.
    The RequestHandler class enables user to execute requests received from flexiManage.
    To do that it provides following steps:
    1. Translates request into list of commands to be executed.
       This stage is called translation.
    2. Executes commands out of the translation list one by one.
       This stage is called execution.
       On failure to execute any of commands, the previously executed commands are reverted in order to rollback system to the state where it was before request receiving.
    3. Updates the persistent database with request result:
       for 'add-X' and 'modify-X' requests stores the request and it's translation into database,
       for 'remove-X' request deletes the stored request and translation from the database.
    4. Handle aggregated requests
    4. Implement Sync and full sync logic 
    Note these stages are exposed as module API-s to enable user to override the default behavior.
    """
    
    def __init__(self, modules, translators, cfg_db, revert_callback = None):
        """Constructor method.
        """
        self.modules = modules
        self.translators = translators
        self.cfg_db = cfg_db
        self.revert_callback = revert_callback

    def __enter__(self):
        return self

    def call(self, request):
        if request['message'] == 'aggregated':
            reply = self._call_aggregated(request['params']['requests'])
        else:
            reply = self._call_simple(request)

        return reply

    def _call_simple(self, request, execute=True, filter=None):
        """Execute single request.

        :param request: The request received from flexiManage.

        :returns: Status codes dictionary.
        """
        try:
            # Translate request to list of commands to be executed
            cmd_list = self._translate(request)

            # Execute list of commands. Do it only if vpp runs.
            # Some 'remove-XXX' requests must be executed
            # even if vpp doesn't run right now. This is to clean stuff in Linux
            # that was added by correspondent 'add-XXX' request if the last was
            # applied to running vpp.
            if execute:
                self._execute(request, cmd_list, filter)

            # Save successfully handled configuration request into database.
            # We need it and it's translation to execute future 'remove-X'
            # requests as they are generated by reverting of correspondent
            # 'add-X' translations from last to the first. As well they are
            # needed to restore VPP configuration on device reboot or start of
            # crashed VPP by watchdog.
            try:
                self.update_db(request, cmd_list, execute)
            except Exception as e:
                self._revert(cmd_list)
                raise e
        except Exception as e:
            err_str = "_call_simple: %s" % str(traceback.format_exc())
            fwglobals.log.error(err_str)
            raise e

        return {'ok':1}

    def _call_aggregated(self, requests, dont_revert_on_failure=False):
        """Execute multiple requests.
        It do that as an atomic operation,
        i.e. if one of requests fails, all the previous are reverted.

        :param requests:    Request list.
        :param dont_revert_on_failure:  If True the succeeded requests in list
                            will not be reverted on failure of any request.
                            This bizare logic is used for device sync feature,
                            where there is no need to restore configuration,
                            as it is out of sync with the flexiManage.

        :returns: Status codes dictionary.
        """
        fwglobals.log.debug("=== start handling aggregated request ===")

        for (idx, request) in enumerate(requests):

            # Don't print too large requests, if needed check print on request receiving
            #
            str_request = json.dumps(request)
            str_request = (str_request[:1000] + '..') if len(str_request) > 1000 else str_request

            try:
                fwglobals.log.debug("_call_aggregated: handle request %s" % str_request)
                self._call_simple(request)
            except Exception as e:
                if dont_revert_on_failure:
                    raise e
                # Revert previously succeeded simple requests
                fwglobals.log.error("_call_aggregated: failed to handle %s. reverting previous requests..." % str_request)
                for request in reversed(requests[0:idx]):
                    try:
                        op = request['message']
                        request['message'] = op.replace('add-','remove-') if re.match('add-', op) else op.replace('remove-','add-')
                        self._call_simple(request)
                    except Exception as e:
                        # on failure to revert move router into failed state
                        err_str = "_call_aggregated: failed to revert request %s while running rollback on aggregated request" % op
                        fwglobals.log.excep("%s: %s" % (err_str, format(e)))
                        if self.revert_callback:
                            self.revert_callback(t)
                        pass
                raise e

        fwglobals.log.debug("=== end handling aggregated request ===")
        return {'ok':1}

    def _translate(self, request):
        """Translate request in a series of commands.

        :param request: The request received from flexiManage.

        :returns: list of commands.
        """
        req    = request['message']
        params = request.get('params')

        api_defs = self.translators.get(req)
        assert api_defs, 'there is no api for request "%s"' % req

        module = self.modules.get(self.translators[req]['module'])
        assert module, 'there is no module for request "%s"' % req

        func = getattr(module, self.translators[req]['api'])
        assert func, 'there is no api function for request "%s"' % req

        if self.translators[req]['api'] == 'revert':
            cmd_list = func(request, self.cfg_db)
            return cmd_list

        cmd_list = func(params) if params else func()
        return cmd_list

    def _execute(self, request, cmd_list, filter=None):
        """Execute request.

        :param request:     The request received from flexiManage.
        :param cmd_list:    Commands list.
        :param filter:      Filter for commands to be executed.
                            If provided and if command has 'filter' field and
                            their values are same, the command will be executed.
                            If None, the check for filter is not applied.
        :returns: None.
        """
        cmd_cache = {}

        req = request['message']

        fwglobals.log.debug("=== start execution of %s ===" % (req))

        for idx, t in enumerate(cmd_list):      # 't' stands for command Tuple, though it is Python Dictionary :)
            cmd = t['cmd']

            # If filter was provided, execute only commands that have the provided filter
            if filter:
                if not 'filter' in cmd or cmd['filter'] != filter:
                    fwglobals.log.debug("_execute: filter out command by filter=%s (req=%s, cmd=%s, cmd['filter']=%s, params=%s)" %
                                        (filter, req, cmd['name'], str(cmd.get('filter')), str(cmd.get('params'))))
                    continue

            try:
                # Firstly perform substitutions if needed.
                # The params might include 'substs' key with list of substitutions.
                self.substitute(cmd_cache, cmd.get('params'))

                if 'params' in cmd and type(cmd['params'])==dict:
                    params = fwutils.yaml_dump(cmd['params'])
                elif 'params' in cmd:
                    params = format(cmd['params'])
                else:
                    params = ''
                fwglobals.log.debug("_execute: %s(%s)" % (cmd['name'], params))

                # Now execute command
                result = None if not 'cache_ret_val' in cmd else \
                    { 'result_attr' : cmd['cache_ret_val'][0] , 'cache' : cmd_cache , 'key' :  cmd['cache_ret_val'][1] }
                reply = fwglobals.g.handle_request({ 'message': cmd['name'], 'params':  cmd.get('params')}, result)
                if reply['ok'] == 0:        # On failure go back revert already executed commands
                    fwglobals.log.debug("%s failed ('ok' is 0)" % cmd['name'])
                    raise Exception("API failed: %s" % reply['message'])

            except Exception as e:
                err_str = "_execute: %s(%s) failed: %s, %s" % (cmd['name'], format(cmd.get('params')), str(e), str(traceback.format_exc()))
                fwglobals.log.error(err_str)
                fwglobals.log.debug("=== failed execution of %s ===" % (req))
                if fwglobals.g.router_api.state_is_starting_stopping():
                    fwutils.dump()
                # On failure go back to the begining of list and revert executed commands.
                self._revert(cmd_list, idx)
                fwglobals.log.debug("=== finished revert of %s ===" % (req))
                raise Exception('failed to ' + cmd['descr'])

            # At this point the execution succeeded.
            # Now substitute the revert command, as it will be needed for complement request, e.g. for remove-tunnel.
            if 'revert' in t and 'params' in t['revert']:
                try:
                    self.substitute(cmd_cache, t['revert'].get('params'))
                except Exception as e:
                    fwglobals.log.excep("_execute: failed to substitute revert command: %s\n%s, %s" % \
                                (str(t), str(e), str(traceback.format_exc())))
                    fwglobals.log.debug("=== failed execution of %s ===" % (req))
                    self._revert(cmd_list, idx)
                    raise e

        fwglobals.log.debug("=== end execution of %s ===" % (req))

    def update_db(self, request, cmd_list=None, executed=False):  
        """Update translation stuff into the database

        :param request:     The request received from flexiManage.
        :param cmd_list:    Commands list.
        :param executed:    Indicates if cmd_list is executed.
        :returns: None.
        """      
        self.cfg_db.update(request, cmd_list, executed)

    def _revert(self, cmd_list, idx_failed_cmd=-1):
        """Revert list commands that are previous to the failed command with
        index 'idx_failed_cmd'.
        :param cmd_list:        Commands list.
        :param idx_failed_cmd:  The index of command, execution of which
                                failed, so all commands in list before it
                                should be reverted.
        :returns: None.
        """
        idx_failed_cmd = idx_failed_cmd if idx_failed_cmd >= 0 else len(cmd_list)

        for t in reversed(cmd_list[0:idx_failed_cmd]):
            if 'revert' in t:
                rev_cmd = t['revert']
                try:
                    reply = fwglobals.g.handle_request(
                        { 'message': rev_cmd['name'], 'params': rev_cmd.get('params')})
                    if reply['ok'] == 0:
                        err_str = "handle_request(%s) failed" % rev_cmd['name']
                        fwglobals.log.error(err_str)
                        raise Exception(err_str)
                except Exception as e:
                    err_str = "_revert: exception while '%s': %s(%s): %s" % \
                                (t['cmd']['descr'], rev_cmd['name'], format(rev_cmd['params']), str(e))
                    fwglobals.log.excep(err_str)

                    if self.revert_callback:
                        self.revert_callback(err_str)

    # 'substitute' takes parameters in form of list or dictionary and
    # performs substitutions found in params.
    # Substitutions are kept in special element which is part of parameter list/dictionary.
    # When this function finishes to perform substitutions, it removes this element from params.
    # The substitution element is a dictionary with one key only - 'substs' and list
    # of substitutions as the value of this key: 
    #   { 'substs': [ {<subst1>} , {<subst2>} ... {<substN>} ] }
    # There are few types of substitutions:
    #   - substitution by function (see 'val_by_func' below)
    #   - substitution by value fetched from cache (see 'val_by_key' below)
    # As well 'substitute' function can
    #   - add new parameter to the original 'params' list/dictionary (see 'add_param' below)
    #   - go over all parameters found in 'params' and replace old value with new (see 'replace' below)
    # If function is used, the function argument can be
    #   - explicit value (see 'arg' below)
    #   - value fetched from cache (see 'arg_by_key' and 'val_by_key' below)
    #
    # That results in following format of single substitution element: 
    #   {
    #       'add_param'    : <name of keyword parameter to be added. Used for dict parameters only>
    #       'val_by_func'  : <function that maps argument into value of new 'add_param' parameter. It should sit in fwutils module>
    #       'arg'          : <input argument for 'val_by_func' function> 
    #   }
    #   {
    #       'add_param'    : <name of keyword parameter to be added. Used for dict parameters only>
    #       'val_by_func'  : <function that maps argument into value of new 'add_param' parameter. It should sit in fwutils module>
    #       'arg_by_key'   : <key to get the input argument for 'val_by_func' function from cache> 
    #   }
    #   {
    #       'add_param'    : <name of keyword parameter to be added. Used for dict parameters only>
    #       'val_by_key'   : <key to get the value of new parameter> 
    #   }
    #   {
    #       'replace'      : <substring to be replaced>
    #       'val_by_func'  : <function that maps argument into value of new 'add_param' parameter. It should sit in fwutils module>
    #       'arg'          : <input argument for 'val_by_func' function> 
    #   }
    #   {
    #       'replace'      : <substring to be replaced>
    #       'val_by_func'  : <function that maps argument into value of new 'add_param' parameter. It should sit in fwutils module>
    #       'arg_by_key'   : <key to get the input argument for 'val_by_func' function from cache> 
    #   }
    #   {
    #       'replace'      : <substring to be replaced>
    #       'val_by_key'   : <key to get the value of new parameter> 
    #   }
    #
    # Once function finishes to handle all substitutions found in the 'substs' element,
    # it removes 'substs' element from the 'params' list/dictionary.
    #
    def substitute(self, cache, params):
        """It takes parameters in form of list or dictionary and
        performs substitutions found in params.
        Once function finishes to handle all substitutions found in the 'substs' element,
        it removes 'substs' element from the 'params' list/dictionary.

        :param cache:          Cache.
        :param params:         Parameters.

        :returns: None.
        """
        if params is None:
            return

        # Fetch list of substitutions
        substs = None
        if type(params)==dict and 'substs' in params:
            substs = params['substs']
        elif type(params)==list:
            for p in params:
                if type(p)==dict and 'substs' in p:
                    substs = p['substs']
                    substs_element = p
                    break
        if substs is None:
            return

        # Go over list of substitutions and perform each of them
        for s in substs:

            # Find the new value to be added to params
            if 'val_by_func' in s:
                func_name = s['val_by_func']
                func = getattr(fwutils, func_name)
                old  = s['arg'] if 'arg' in s else cache[s['arg_by_key']]
                new  = func(*old) if type(old) == list else func(old)
                if new is None:
                    raise Exception("fwutils.py:substitute: %s failed to map %s in '%s'" % (func, old, format(params)))
            elif 'val_by_key' in s:
                new = cache[s['val_by_key']]
            else:
                raise Exception("fwutils.py:substitute: not supported type of substitution source in '%s'" % format(params))

            # Add new param/replace old value with new one
            if 'add_param' in s:
                if type(params) is dict:
                    if 'args' in params:        # Take care of cmd['cmd']['name'] = "python" commands
                        params['args'][s['add_param']] = new
                    else:                       # Take care of rest commands
                        params[s['add_param']] = new
                else:  # list
                    params.insert({s['add_param'], new})
            elif 'replace' in s:
                old = s['replace']
                if type(params) is dict:
                    raise Exception("fwutils.py:substitute: 'replace' is not supported for dictionary in '%s'" % format(params))
                else:  # list
                    for (idx, p) in enumerate(params):
                        if fwutils.is_str(p):
                            params.insert(idx, p.replace(old, new))
                            params.remove(p)
            else:
                raise Exception("fwutils.py.substitute: not supported type of substitution in '%s'" % format(params))

        # Once all substitutions are made, remove substitution list from params
        if type(params) is dict:
            del params['substs']
        else:  # list
            params.remove(substs_element)

    def restore_configuration(self):
        """Restore configuration.
        Run all configuration translated commands.
        """
        try:
            fwglobals.log.info("===restore configuration: started===")

            requests = self.cfg_db.dump(keys=True)
            if requests:
                for req in requests:
                    reply = fwglobals.g.handle_request(req)
                
            return True
        except Exception as e:
            fwglobals.log.excep("restore_configuration failed: %s" % str(e))

        fwglobals.log.info("====restore configuration: finished===")
        return True

    def sync_full(self, incoming_requests):
        fwglobals.g.agent_api._reset_device_soft()

        sync_request = {
            'message':   'aggregated',
            'params':    { 'requests': incoming_requests },
            'internals': { 'dont_revert_on_failure': True }
        }

        reply = self.call(sync_request)

        if reply['ok'] == 0:
            raise Exception(" _sync_device: router full sync failed: " + str(reply.get('message')))

        return True

    def sync(self, incoming_requests, full_sync=False):
        incoming_requests = list(filter(lambda x: x['message'] in self.translators, incoming_requests))   

        # get sync lists
        sync_list = self.cfg_db.get_sync_list(incoming_requests)

        if len(sync_list) == 0 and not full_sync:
            fwglobals.log.info("_sync_device: sync_list is empty, no need to sync")
            return True
        
        fwglobals.log.debug("_sync_device: start smart sync")

        sync_request = {
            'message':   'aggregated',
            'params':    { 'requests': sync_list },
            'internals': { 'dont_revert_on_failure': True }
        }

        reply = self.call(sync_request)

        if reply['ok'] == 1 and not full_sync:
            fwglobals.log.debug("_sync_device: smart sync succeeded")
            return True

        # Full sync
        return self.sync_full(incoming_requests)